/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: CardboardDevice.proto
 *
 */

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

///  *
///   Message describing properties of a VR head mount device (HMD) which uses an
///   interchangeable smartphone as a display (e.g. Google Cardboard).
///  
///   While some properties are certain (e.g. inter_lens_distance), others
///   represent nominal values which may be refined depending on context (e.g.
///   viewport_angles).
///  
///   Lengths are in meters unless noted otherwise.  Fields are _required_
///   unless noted otherwise.
///  
///   Some context on why this set of parameters are deemed necessary and
///   sufficient:
///      * FOV scale can be reasonably approximated from lens-to-screen distance
///        and display size (i.e. knowing lens focal length isn't crucial).
///      * Lenses are assumed to be horizontally centered with respect to
///        display.
///      * The display is not necessarily vertically centered.  For interchangeable
///        phones where the device rests against a tray, we can derive
///        the vertical offset from tray-to-lens height along with phone-specific
///        bezel and screen sizes (supplied separately).
struct DeviceParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vendor"),
    2: .same(proto: "model"),
    3: .standard(proto: "screen_to_lens_distance"),
    4: .standard(proto: "inter_lens_distance"),
    5: .standard(proto: "left_eye_field_of_view_angles"),
    11: .standard(proto: "vertical_alignment"),
    6: .standard(proto: "tray_to_lens_distance"),
    7: .standard(proto: "distortion_coefficients"),
    10: .standard(proto: "has_magnet"),
    12: .standard(proto: "primary_button"),
  ]

  ///   String identifying the device's vendor (e.g. "Google, Inc.").
  ///   A device's [vendor, model] pair is expected to be globally unique.
  private var _vendor: String? = nil
  var vendor: String {
    get {return _vendor ?? ""}
    set {_vendor = newValue}
  }
  var hasVendor: Bool {
    return _vendor != nil
  }
  mutating func clearVendor() {
    return _vendor = nil
  }

  ///   String identifying the device's model, including revision info if
  ///   needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
  ///   expected to be globally unique.
  private var _model: String? = nil
  var model: String {
    get {return _model ?? ""}
    set {_model = newValue}
  }
  var hasModel: Bool {
    return _model != nil
  }
  mutating func clearModel() {
    return _model = nil
  }

  ///   Distance from the display screen to the optical center of lenses.
  private var _screenToLensDistance: Float? = nil
  var screenToLensDistance: Float {
    get {return _screenToLensDistance ?? 0}
    set {_screenToLensDistance = newValue}
  }
  var hasScreenToLensDistance: Bool {
    return _screenToLensDistance != nil
  }
  mutating func clearScreenToLensDistance() {
    return _screenToLensDistance = nil
  }

  ///   Horizontal distance between optical center of the lenses.
  private var _interLensDistance: Float? = nil
  var interLensDistance: Float {
    get {return _interLensDistance ?? 0}
    set {_interLensDistance = newValue}
  }
  var hasInterLensDistance: Bool {
    return _interLensDistance != nil
  }
  mutating func clearInterLensDistance() {
    return _interLensDistance = nil
  }

  ///   Four-element tuple (left, right, bottom, top) of left eye's view extent
  ///   angles relative to center, assuming the following:
  ///       * eye is aligned with optical center of lens
  ///       * display screen is equal or larger than extents viewable through lens
  ///       * nominal eye-to-lens distance
  ///       * mirrored field of view will be applied to the right eye
  ///   These values are essentially used as an optimization to avoid rendering
  ///   pixels which can't be seen.
  var leftEyeFieldOfViewAngles: [Float] = []

  ///   Set according to vertical alignment strategy-- see enum comments above.
  ///   NOTE: If you set this to CENTER, see special instructions for the
  ///   tray_to_lens_distance field below.
  private var _verticalAlignment: DeviceParams.VerticalAlignmentType? = nil
  var verticalAlignment: DeviceParams.VerticalAlignmentType {
    get {return _verticalAlignment ?? DeviceParams.VerticalAlignmentType.bottom}
    set {_verticalAlignment = newValue}
  }
  var hasVerticalAlignment: Bool {
    return _verticalAlignment != nil
  }
  mutating func clearVerticalAlignment() {
    return _verticalAlignment = nil
  }

  ///   If the phone is aligned vertically within the device by resting against
  ///   a fixed top or bottom tray, this is the distance from the tray to
  ///   optical center of the lenses.
  ///   NOTE: Due to a bug in initial versions of the SDK's, this field
  ///   must be set explicitly to .035 when vertical_alignment = CENTER.
  private var _trayToLensDistance: Float? = nil
  var trayToLensDistance: Float {
    get {return _trayToLensDistance ?? 0}
    set {_trayToLensDistance = newValue}
  }
  var hasTrayToLensDistance: Bool {
    return _trayToLensDistance != nil
  }
  mutating func clearTrayToLensDistance() {
    return _trayToLensDistance = nil
  }

  ///   Coefficients Ki for pincushion distortion function which maps
  ///   from position on real screen to virtual screen (i.e. texture) relative
  ///   to optical center:
  ///  
  ///      p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
  ///  
  ///   where r is the distance in tan-angle units from the optical center,
  ///   p the input point, and p' the output point.  Tan-angle units can be
  ///   computed as distance on the screen divided by distance from the
  ///   virtual eye to the screen.
  var distortionCoefficients: [Float] = []

  ///   Optionally, whether the head mount uses a magnet in any part of its
  ///   design.  Intended as hint as to whether phone's magnetometer is
  ///   available for tasks such as orientation tracking.
  private var _hasMagnet: Bool? = nil
  var hasMagnet: Bool {
    get {return _hasMagnet ?? false}
    set {_hasMagnet = newValue}
  }
  var hasHasMagnet: Bool {
    return _hasMagnet != nil
  }
  mutating func clearHasMagnet() {
    return _hasMagnet = nil
  }

  ///   Specify primary input mechanism of the HMD.  Intended for advisory
  ///   purposes only, to address simple questions such as "can HMD
  ///   be used with apps requiring a physical button event?" or "what icon
  ///   should be used to represent button action to the user?".
  private var _primaryButton: DeviceParams.ButtonType? = nil
  var primaryButton: DeviceParams.ButtonType {
    get {return _primaryButton ?? DeviceParams.ButtonType.magnet}
    set {_primaryButton = newValue}
  }
  var hasPrimaryButton: Bool {
    return _primaryButton != nil
  }
  mutating func clearPrimaryButton() {
    return _primaryButton = nil
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum VerticalAlignmentType: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
    typealias RawValue = Int

    ///   phone rests against a fixed bottom tray
    case bottom // = 0

    ///   phone screen assumed to be centered w.r.t. lenses
    case center // = 1

    ///   phone rests against a fixed top tray
    case top // = 2

    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
      0: .same(proto: "BOTTOM"),
      1: .same(proto: "CENTER"),
      2: .same(proto: "TOP"),
    ]

    init() {
      self = .bottom
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .bottom
      case 1: self = .center
      case 2: self = .top
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .bottom: return 0
      case .center: return 1
      case .top: return 2
      }
    }

  }

  enum ButtonType: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
    typealias RawValue = Int

    ///   No physical button, and touch screen is not easily accessible.
    case none // = 0

    ///   HMD has integrated magnet switch similar to original Cardboard.
    case magnet // = 1

    ///   At least a portion of touch screen is easily accessible to user for taps.
    case touch // = 2

    ///   Touch screen is triggered indirectly via integrated button on the HMD.
    case indirectTouch // = 3

    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
      0: .same(proto: "NONE"),
      1: .same(proto: "MAGNET"),
      2: .same(proto: "TOUCH"),
      3: .same(proto: "INDIRECT_TOUCH"),
    ]

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .magnet
      case 2: self = .touch
      case 3: self = .indirectTouch
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .magnet: return 1
      case .touch: return 2
      case .indirectTouch: return 3
      }
    }

  }

  init() {}

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &_vendor)
      case 2: try decoder.decodeSingularStringField(value: &_model)
      case 3: try decoder.decodeSingularFloatField(value: &_screenToLensDistance)
      case 4: try decoder.decodeSingularFloatField(value: &_interLensDistance)
      case 5: try decoder.decodeRepeatedFloatField(value: &leftEyeFieldOfViewAngles)
      case 11: try decoder.decodeSingularEnumField(value: &_verticalAlignment)
      case 6: try decoder.decodeSingularFloatField(value: &_trayToLensDistance)
      case 7: try decoder.decodeRepeatedFloatField(value: &distortionCoefficients)
      case 10: try decoder.decodeSingularBoolField(value: &_hasMagnet)
      case 12: try decoder.decodeSingularEnumField(value: &_primaryButton)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = _vendor {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = _model {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = _screenToLensDistance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }
    if let v = _interLensDistance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    }
    if !leftEyeFieldOfViewAngles.isEmpty {
      try visitor.visitPackedFloatField(value: leftEyeFieldOfViewAngles, fieldNumber: 5)
    }
    if let v = _trayToLensDistance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    }
    if !distortionCoefficients.isEmpty {
      try visitor.visitPackedFloatField(value: distortionCoefficients, fieldNumber: 7)
    }
    if let v = _hasMagnet {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }
    if let v = _verticalAlignment {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    }
    if let v = _primaryButton {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: DeviceParams) -> Bool {
    if _vendor != other._vendor {return false}
    if _model != other._model {return false}
    if _screenToLensDistance != other._screenToLensDistance {return false}
    if _interLensDistance != other._interLensDistance {return false}
    if leftEyeFieldOfViewAngles != other.leftEyeFieldOfViewAngles {return false}
    if _verticalAlignment != other._verticalAlignment {return false}
    if _trayToLensDistance != other._trayToLensDistance {return false}
    if distortionCoefficients != other.distortionCoefficients {return false}
    if _hasMagnet != other._hasMagnet {return false}
    if _primaryButton != other._primaryButton {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
